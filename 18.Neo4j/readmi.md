## 1. Придумать 2-3 варианта, когда применима графовая база данных ##
### 1.1 Социальная сеть. ###  
В социальной сети пользователи взаимодействуют друг с другом через "дружбу", "подписки",
"лайки" и другие формы связей. Это создает граф, где узлы — это пользователи, а ребра — их взаимодействия. 
Графовые базы данных, такие как Neo4j, позволяют эффективно выполнять запросы на социальные связи, например, 
поиск друзей друзей или нахождение ближайших взаимных друзей. Пример: узнать, кто из друзей пользователя также 
подписан на одного и того же блогера.

### 1.2 Маркетинг и рекомендации товаров. ###  
Рекомендательные системы используют графовые базы данных для построения связей 
между пользователями и товарами. Графовая модель помогает быстро находить товары, которые покупали пользователи с 
похожими интересами, или товары, которые имеют косвенные связи через другие покупки. Пример: предложить пользователю 
товар на основе покупок других клиентов с аналогичными предпочтениями.

### 1.3 Управление логистикой и путями. ###  
Графовые базы данных эффективны для задач, связанных с управлением транспортными 
путями и логистикой. Например, нахождение кратчайшего маршрута между двумя городами с учетом различных типов дорог и 
перекрестков — типичная задача, которую можно решить через графы. Пример: рассчитать самый быстрый маршрут доставки с 
учетом пробок и грузоподъемности транспорта.

## 2. Воспользоваться моделью, данными и командами из лекции или одним из своих примеров из пункта 1 и реализовать аналог в любой выбранной БД (реляционной или нет - на выбор). Сравнить команды. Написать, что удобнее было сделать в выбранной БД, а что в Neo4j и привести примеры. ##
### 2.1 Нахождения друзей друзей в Neo4j. ###  
Узлы представляют пользователей, а связи — их дружбу.
```
MATCH (user:Person {name: 'Иван'})-[:FRIEND]->(friend)-[:FRIEND]->(friendOfFriend)
RETURN friendOfFriend
```
В реляционной базе данных нам придется создать две таблицы: одну для пользователей и одну для связей между ними. Пример запросов:
```
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);
```
```
CREATE TABLE friendships (
  user_id INT REFERENCES users(id),
  friend_id INT REFERENCES users(id),
  PRIMARY KEY (user_id, friend_id)
);
```
```
SELECT u2.name
FROM users u
JOIN friendships f1 ON u.id = f1.user_id
JOIN friendships f2 ON f1.friend_id = f2.user_id
JOIN users u2 ON f2.friend_id = u2.id
WHERE u.name = 'Иван';
```
### 2.2 Neo4j: ###  
Интуитивное представление данных как узлов и ребер. Графовая структура данных более естественна для задач, связанных с социальными сетями и связями между объектами.
  Более простой и быстрый доступ к сложным запросам с многими уровнями связей, как, например, поиск друзей друзей.
  Язык Cypher позволяет писать запросы, которые напрямую выражают смысл связей.

PostgreSQL:
  Если задачи больше связаны с атрибутами объектов (пользователей), а не с их связями, то реляционная модель более оптимальна.
  PostgreSQL имеет хорошую поддержку транзакций и сложных аналитических запросов, что делает его более удобным для задач, где важно агрегировать большие объемы данных.  
Итог:
  Пример на Neo4j проще и более наглядный, особенно когда работа связана с отношениями между объектами. Однако, в реляционной БД удобнее выполнять более сложные запросы, не связанные с графовой структурой, и легче интегрировать данные с другими системами.
